## 리액트를 다룰 때 갖고 있어야하는 생각들

### DOM

- Document Object Model의 약자
- 브라우저가 HTML을 파싱해 객체 형태로 만든것

```html
<div>
  <span>이현진</span>
  <span>소마</span>
</div>
```

예를 들어, 위와 같은 구조가 있다고 했을 때 브라우저는 이 문자열을 다루기 쉬운 객체 형태로 바꿔준다. (이 객체를 DOM이라고 한다)

!(dom)[https://velog.velcdn.com/images/hyunjine/post/cfbcd4c4-4d6f-492a-bdd9-162ea47ffb9c/image.png]

개발자는 javascript를 이용해 dom을 조작하여 웹 애플리케이션을 개발한다.

하지만 javascript로 dom을 직접 조작하는 것은 여러 단점이 있다.

1. Javascript로 DOM을 조작할 때 HTML의 구조를 파악하기 어렵다. (DOM을 직접 생성, 수정, 삭제할 때 구조 파악이 힘듬)
2. 표준을 따르는 브라우저도 많지만 그 안에서도 다른 동작을 가지고 있을 수 있다.
3. [Live Collection과 Static Collection](https://im-developer.tistory.com/110)
   (DOM API의 반환값이 일관성이 없다)

Live Collection은 DOM API가 반환한 값이 Live한 상태를 의미한다. 즉, DOM의 실시간 변경사항에 따라 언제든 값이 바뀔 수 있다. 반면, Static Collection은 DOM의 실시간 변경사항에 따라 값이 바뀌지 않는다.

DOM API는 반환하는 값이 Live할 수도 있고, Static 할 수도 있기 때문에 일관성이 없다고 표현한다.

DOM API가 일관성이 없고 사용하기 불편하다면 어떻게 해야할까?

가장 간단한 답으로, DOM API를 사용하지 않는 방법이 있다. DOM API를 직접 사용하지 않고 중간에 매개체를 두어서 DOM을 조작할 수 있다.

이 매개체가 바로 React이다!

React는 DOM조작과 같이 어려운 일은 자신이 하고, 개발자에게는 훨씬 편리한 API를 제공해준다. 마치 HTML이라는 문자열을 직접 다루기 어렵기 때문에 DOM이라는 객체를 만든 것처럼, DOM을 직접 다루기 어렵기 때문에 React를 만든 것이라고 할 수 있다.

React는 웹 애플리케이션의 UI를 재사용 가능한 컴포넌트들을 모아서 구성한다. 각 컴포넌트에는 데이터 모델이 존재한다. 애플리케이션의 UI와 상호작용하려면 UI에 내재하는 데이터 모델을 바꿈으로써 상호작용을 할 수 있다.

이 데이터 모델을 React에서는 State, 즉 상태라고 한다.

상태: 주어진 시간에 대해 시스템을 나타내는 것, 언제든지 변경될 수 있고 상태가 업데이트되면 React 컴포넌트는 렌더링됨

렌더링: React가 컴포넌트에게 현재 Props와 State에 기반하여 UI에 어떻게 보여지고 싶은지 알려달라고 요청하는 과정. 즉, 함수 컴포넌트들을 호출하는 것이라고 할 수 있으며 함수에서 반환하는 JSX는 시간에 따른 UI의 스냅샷과 같음

1. 리액트는 트리의 최상단부터 렌더 패스(render pass)를 시작
2. 업데이트가 필요한 컴포넌트는 렌더링을 함
3. 여기서 중요한 점은, 리액트는 부모 컴포넌트가 렌더링되면 모든 자식 컴포넌트를 재귀적으로 렌더링함!

- 리액트는 VirtualDOM을 활용한다. 기존 VirtualDom과 상태 업데이트 후의 VirtualDOM에서 바뀐 부분만을 계산(diffing)하여 실제 바뀐 부분만 DOM에 적용한다. : 리액트에서는 이를 Reconciliation(재조성)이라고 함

- 렌더링을 두 단계로 쪼갤 수 있음

1. Render phase(렌더 단계) : 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 과정이 이루어지는 단계 (virtualDom 조작 단계)
2. Commit phase(커밋 단계) : 변경 사항을 실제 DOM에 적용하는 단계

- 렌더링은 기본적으로 상태 업데이트에 의해 발생됨. 따라서 리액트는 상태관리를 어떻게 하느냐에 따라 애플리케이션의 미래가 결정됨. 불필요하거나 중복된 상태는 버그의 일반적인 원인이 될 수 있음
- 적절한 상태를 적절한 컴포넌트에 배치시켜야 함!

- 상태 끌어올리기 (Lifting State Up) : 두 컴포넌트에서 변경되어야 하는 상태는 중복 상태이므로 해당 컴포넌트들에서 상태를 제거하고 가장 가까운 공통 부모로 상태를 이동시킨 후, props를 통해 전달함
  이렇게 상태를 끌어올린 후 하위 컴포넌트들에게 Props로 전달!

- 단방향 데이터 흐름: React에서는 데이터의 흐름이 상위 컴포넌트에서 하위 컴포넌트로(단방향으로) 흐름

---

지금까지 상태를 애플리케이션에 분배하고 다뤄봤다. 브라우저내에서 모든걸 처리할 수 있다면 클라이언트 상태로도 충분하지만 대다수의 애플리케이션은 서버 상태가 존재한다.

서버 상태는 아래와 같은 특성을 지닌다.

- 사용자의 제어를 벗어난 위치에서 원격으로 유지된다.
- 비동기 요청을 통해 fetching 또는 updating이 가능하다.
- 소유권을 공유한다. 즉 사용자 모르게 다른 사용자가 변경할 수 있다.
- 시간이 지남에 따라 stale 또는 outdated 된다.

리액트는 ui 라이브러리이기 때문에 데이터를 fetching 하는 것에는 관심이 없다. 단지 fetching한 데이터를 ui에 반영시키는 것에만 관심이 많다.

리액트는 상태에 따라 ui를 어떻게 렌더링할지에 관심이 있기 때문에 서버 상태를 다루려면 여러 상태를 정의해야한다. Loading, Error, Success 상태를 정의하여 각각의 상태별로 매 렌더링마다 ui의 스냅샷을 찍어서 보여준다.

React에서는 상태를 업데이트하는 로직이 복잡해지면 reducer를 사용하듯이 컴포넌트 내부에 loading, error, success와 같은 상태를 두지 않고 전역 상태 관리자인 redux를 사용해 상태를 업데이트하는 로직을 컴포넌트 외부로 빼내서 비동기 요청에 대한 렌더링 로직을 작성했다.

전역 상태관리 라이브러리인 Redux의 역할이 과연 API요청에 대한 각각의 상태를 정의해 렌더링 로직을 작성하는 걸까?
답은 아니라고 생각한다. 전역 상태관리자의 역할은 전체 애플리케이션에서 정말 전역적으로 관리해야하는 상태(theme, 사이드바 상태 등)를 가지고 있어야 한다.

기존에는 API요청의 상태에 따라 적합한 UI를 보여주기 위해 컴포넌트 외부에 수많은 보일러 플레이트 코드를 작성해야 했다.

리액트 쿼리는 이를 해결한다. 리액트 쿼리의 역할은 명확하다.

> 서버 상태를 관리하기위해 필요했던 보일러플레이트 코드를 제거한다. 그리고 단 몇줄의 코드로 이를 대체한다.

React Query를 사용하면 여러 상태를 정의해야하는 문제는 해결된다. 하지만 컴포넌트가 isLoading과 같은 상태일 때 반환할 UI를 정의해줘야 한다.

이는 UI의 일관성을 해친다.

Suspense는 이를 해결한다. Suspense의 목표는 서버상태를 읽어오는 것을 React의 props와 state처럼 쉽게 다루는 것이다.

```javascript
<Suspense fallback={<Spinner />}>
  <Component />
</Suspense>
```

이렇게 비동기적으로 데이터를 불러오는 컴포넌트를 Suspense로 감싸고 fallback으로 보여줄 컴포넌트를 전달한다. 이렇게하면 기존 UI의 로딩 상태를 명령형(imperative) 방식으로 정의해야했던 것을 React의 패러다임에 맞게 선언적(declarative)인 방식으로 바꿀 수 있다.

이제 마지막으로 React v18에 대해 이야기해보자.
리액트팀이 Async rendering 이라는 개념을 소개한 이후 2161이란 시간이 결렸다.

리액트 팀의 목표는 하나였다.

> 성능이 좋은 리액트를 만들어서 수백만개의 리액트로 만들어진 웹사이트 성능을 높인다!

가장 큰 문제는 리액트가 아닌 리액트를 만든 언어에 있었다.
리액트는 자바스크트 위에서 만들어졌기 때문에 자바스크립트의 제약을 따를 수밖에 없다.
특히 자바스크립트가 브라우저 위에서 동작하는 방식을 따른다.

브라우저의 메인 스레드는 싱글스레드로, 한번에 하나의 작업만 처리가능하다.
HTML을 파싱하거나 Javascript를 실행하거나 화면에 보이는 내용을 렌더링하는데 사용된다.

리액트를 비롯한 대다수의 ui 라이브러리 작동 방식도 이 한계에 종속될 수밖에 없다. 리액트도 화면에 그리기 위한 내부 연산, 즉 렌더링을 시작해서 화면을 완성할 때까지 실행을 멈출 수 없다. 이를 리액트 팀에서는 블로킹 렌더링이라고 부른다.

정확히는 리액트 18이전까지 그랬다. 리액트18에서는 동시성 기능(Concurrent features)이 추가되었다.

동시성: 두개 이상의 독립적인 작업을 잘게 나누어 Context Switching을 하며 동시에 실행되는 것처럼 보이도록 프로그램을 구조화하는 방법

동시성 기능을 활용하면 렌더링을 잘게 쪼개어 상태 업데이트에 우선순위를 두어 좀 더 긴급한 상태 업데이트를 먼저 수행할 수 있다.

### 정리

- 리액트는 DOM 조작의 문제점을 해결하기 위해 만들었다.
- 리액트는 Reconciliation(재조정) 과정을 통해 DOM을 업데이트한다.
- 리액트의 핵심은 상태 관리이다.
- 리액트에서 Concurrent Feature를 활용해 렌더링 우선순위를 정할 수 있다.

## 리액트의 핵심 원칙은 UI를 값이라는 것이다.

리액트는 ui를 변수에 저장할 수 있으며 값으로 전달할 수 있다. 즉 리액트는 Value UI이다.
